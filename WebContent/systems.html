<html>

<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Software systems</title>

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
<script type="text/javascript" src="http://sketch2.csail.mit.edu/SynthesisCourse/library.js"></script>
<script type="text/javascript" src="overrides.js"></script>
<link href="style.css" rel="stylesheet" type="text/css">
</head>

<body onresize="resizing()">


<div class="header">
<h1 style="color: rgb(165, 42, 42);">Understanding the World Through Code</h1>
<h2 style="color: 'black';">Funded through the NSF Expeditions in Computing Program</h2>
<div class="logos">
<img title='mit' src='images/mit.png' height='100%' />
<img title='ut' src='images/ut.png' height='100%'/>
<img title='caltech' src='images/caltech.png' height='100%'/>
<img title='rice' src='images/rice.png' height='100%'/>
<img title='penn' src='images/penn.png' height='100%'/>
<img title='stanford' src='images/stanford.png' height='100%'/>
</div>
<div id='navicon.div' class='navicon'>
<img id = 'navicon' src="images/burger.rest.png" 
onmouseenter="iconEnter(this, 'burger')"
onmouseleave="iconLeave(this, 'burger')"
onclick = 'toggleNav()'
title="Navigation" width="34pt"></img>
</div>
</div>


<div id="navigator" class="sidenav">
<a href="#about">Lecture 1</a> 
<a href="#services">Lecture 2</a> 
<a href="#clients">Lecture 3</a> 
<a href="#contact">Lecture 4</a>
</div>
<script type="text/javascript">
loadNavBar();
</script>

<div class="content">

<h1>Software systems</h1>


While many of the research questions in this proposal have been motivated from the 
natural sciences (e.g., organic chemistry or understanding animal behavior), 
we believe that the proposed ideas can also be gainfully applied to address  
a number of concerns of real-world software systems. 

In many ways, reasoning large scale software is akin to scientific discovery. 
For example, consider software security: As new attacks and exploits are discovered 
almost on a daily basis and existing software is patched to address these exploits, 
it becomes increasingly important to construct models that explain what constitutes 
a security vulnerability or malicious behavior. 


<h2>Working with code</h2>
    Software engineering applications were one of the original driving forces behind the development of some of the 
    neurosymbolic techniques leveraged by our project. We are continuing to explore applications ranging from program manipulation 
    to bug finding and vulnerability detection. Below are some of our ongoing efforts in this space. 


<div class="project">
    <h1>  Neural-guided Program Synthesis for Code Transpilation </h1>
    <p>
        Due to the rapidly evolving nature of modern programming, many code bases need to be modernized by either re-writing them in
        an entirely different language or updating them to use different APIs. Motivated by this problem, our project <cite> mariano2022automated-ours </cite> aims to automate
        code transpilation using neural-guided program synthesis. We address this problem using a synthesis-based approach because the
        modernized version of the code is often written in a higher level of abstraction than the original version, making techniques
        like syntax-directed translation unsuitable in this setting. To address the challenging nature of the synthesis problem, we
        take a neural-guided approach, meaning that the search performed by the synthesizer is guided by a neural network that has
        been trained off-line. Our approach uses a new neural architecture called a cognate grammar network suitable for the
        transpilation task and leverages a novel pruning technique to rule out incorrect translations. A publication summarizing these
        results will appear at OOPSLA’22, with extensions and applications to other problems (e.g., de-obfuscation) being underway.
    </p>
</div>


<h2>Working with data</h2>
    Another early and promising application of neurosymbolic techniques is working with data, whether for the purpose of manipulation 
    and visualization, or for the efficient storage and querying of it.

<div class="project">
    <h1>  Querying and Visualizing Scientific Data using Program Synthesis </h1>
    <p>
        Data querying and visualization play a key role in many scientific disciplines, ranging from biology to physics. The goal of this project is to make it easier for scientists to query and  visualize data using (neuro-symbolic) program synthesis.
    </p>
    
    <p>
        One aspect of this project focuses on querying data that is comprised of  a combination of structured formats (e.g., table or XML document) and unstructured information (e.g., text). Such hybrid formats are very common in scientific applications, but they are not very amenable to data querying. In particular, purely neural approaches (e.g., developed for natural language processing) fail to adequately handle the structured representation, while purely programmatic querying techniques (e.g., based on SQL-like languages) fail to handle unstructured text. Our research addresses this problem by developing neuro-symbolic query DSLs and corresponding learning/synthesis techniques for making it easier to query data in such hybrid formats. A publication summarizing our initial findings in this context appeared at PLDI’21.
    </p>
    <p>
        Another aspect of this project focuses on generating visualizations from (tabular) data using program synthesis. We consider two ways to simplify visualization authoring. In one thread of work, we consider a user interaction scenario where the user generates a partial visualization with the aid of graphical user interface, and our method completes the visualization by synthesizing a suitable visualization script that is consistent with the user-provided partial visualization. In another thread of work, we consider a natural language interface (NLI) for visualizations wherein a visualization program is synthesized based on the user’s natural language description. Initial results from this work appeared at POPL and CHI, with newer results involving NLIs currently under peer-review.
    </p> 
</div>


<h2>Understanding software vulnerabilities.</h2>

What constitutes a software vulnerability is not a static notion, but one that 
evolves dynamically as attackers discover new exploits or reasonable security-theoretic 
assumptions are challenged over time and become obsolete 
(e.g., regarding what constitutes a sufficiently good source of entropy). 
As a result, security experts must invest significant time and effort into  
understanding root causes of vulnerable behavior, finding instances of these 
vulnerabilities, and making recommendations about how to fix these vulnerabilities. 
We believe that our proposed techniques can greatly facilitate the jobs of security 
analysists and software developers and ultimate make secure software development a much 
easier task than it is today.

In this context, there are many sources of existing data that we can learn from. These 
include known vulnerabilities as cataloged in CVE databases 
and patches to existing software.  We can learn such data to both develop a model of 
<i>what</i> constitutes a vulnerability as well as <i>how</i> to
 fix the underlying vulnerability. Recent efforts by our team and others have already 
 demonstrated the feasibility of this approach for some specific types of 
 vulnerabilities<cite>long2015staged</cite><cite>Long2016</cite><cite>apisan</cite>, 
 and we believe that the ideas outlined in this proposal can help us dramatically 
 expand the class of vulnerabilities that can be automatically detected and patched.


<h2>Characterizing and detecting malware.</h2> 
While vulnerabilities correspond to unintended mistakes in otherewise-benign code, 
another huge problem in software security is the presence of malicious applications 
that masquerade as useful  software. Malicious applications are becoming a particularly 
severe concern due to the soaring popularity of smart phone applications and the 
near-infeasibility of manually vetting the enormous number of applications that 
are submitted to a growing number of app markets. We believe that our proposed ideas 
are ideally suited for understanding and detecting real-world malware by automatically 
synthesizing programmatic models  of malicious behavior.

While there is a large body of work on detecting malicious behavior using machine 
learning (and, in particular, deep learning), such techniques are not widely adopted in 
industry due to the opaque nature of these models. In particular, a significant 
drawback of standard machine learning models is that they fail to provide <i>evidence
 of malice</i> in cases where an application is classified as malware. 
 Prior work by PIs Dillig and Bastani has shown that it is feasible to 
 automatically synthesize such malware-characterizing programs given samples of benign 
 and malicious applications<cite>feng2017automated</cite>. Building on this prior work, 
 we plan to develop techniques that can both synthesize models for a much larger class 
 of malware and allow security analysts gain insights into malicious behavior by 
 querying the learned models    (e.g., ``which of these applications belong to the 
 same malware family?'' or ''what changes are required to make this otherwise-useful 
 application benign?'').



<script>
processDocument();
</script>

<div class="footnotes">

<footnotes>

</footnotes>

</div>
</div>

</body>



</html>